# CORS & Mixed Content Resolution

## Problem
The Hlidskjalf UI on `https://hlidskjalf.ravenhelm.dev` encountered three critical issues:

1. **CORS Errors**: Frontend was making API calls to `https://hlidskjalf-api.ravenhelm.test` instead of `.dev`
2. **Mixed Content**: OpenTelemetry was trying to send traces to `http://alloy.ravenhelm.test:4318` from an HTTPS page
3. **API 401 Unauthorized**: Even after fixing CORS, the API was returning 401 because Traefik's OAuth2-Proxy middleware was blocking the OPTIONS preflight request before CORS headers could be applied

## Root Cause
The frontend code had dynamic URL resolution logic, but:
- The container wasn't rebuilt after code changes
- Telemetry endpoint was trying to use HTTP from HTTPS pages (mixed content violation)
- CORS middleware in Traefik wasn't applied before authentication middleware

## Solution

### 1. Frontend API Client (`hlidskjalf/ui/src/lib/api.ts`)
Already had dynamic resolution logic (no changes needed):
```typescript
const API_BASE = typeof window !== 'undefined' 
  ? window.location.origin.replace('hlidskjalf.', 'hlidskjalf-api.')
  : process.env.NEXT_PUBLIC_API_URL || "https://hlidskjalf-api.ravenhelm.test";
```

### 2. Frontend Telemetry (`hlidskjalf/ui/src/lib/telemetry.ts`)
**Changed from**: Direct connection to `http://alloy.ravenhelm.test:4318`  
**Changed to**: Route through Traefik using the page's protocol

```typescript
function getOTLPEndpoint(): string {
  if (typeof window === 'undefined') {
    return process.env.NEXT_PUBLIC_OTLP_ENDPOINT || 'https://otel.ravenhelm.test';
  }
  
  const hostname = window.location.hostname;
  const protocol = window.location.protocol; // 'http:' or 'https:'
  const domain = hostname.split('.').slice(-2).join('.');
  
  // Route through Traefik using the otel subdomain
  return `${protocol}//otel.${domain}`;
}
```

### 3. Traefik Dynamic Configuration (`ravenhelm-proxy/dynamic.yml`)
**Added staging route** for OTLP endpoint:
```yaml
otel-staging:
  rule: "Host(`otel.ravenhelm.dev`)"
  service: otel-svc
  middlewares:
    - secure-headers
  tls:
    certResolver: letsencrypt
```

### 4. Backend CORS (`hlidskjalf/src/main.py`)
**Already configured correctly** with `.dev` domains:
```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://hlidskjalf.ravenhelm.test",
        "https://hlidskjalf.ravenhelm.dev",  # ✓ Already present
        "https://hlidskjalf.ravenhelm.ai",
        ...
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

### 5. Traefik CORS Middleware (Already in place)
The `cors-ravenhelm` middleware was already defined and applied via the `protected-staging-cors` chain, ensuring CORS headers are added before authentication.

## Deployment Steps
1. **Rebuilt frontend container**: `docker-compose build hlidskjalf-ui`
2. **Restarted frontend**: `docker-compose restart hlidskjalf-ui`
3. **Restarted Traefik**: `docker restart ravenhelm-traefik`

## Verification
```bash
# Test CORS headers
curl -s -H "Origin: https://hlidskjalf.ravenhelm.dev" \
  -X OPTIONS https://hlidskjalf-api.ravenhelm.dev/api/v1/overview -I \
  | grep -i "access-control"

# Expected output:
# access-control-allow-credentials: true
# access-control-allow-origin: https://hlidskjalf.ravenhelm.dev

# Test OTLP endpoint
curl -s -o /dev/null -w "%{http_code}" https://otel.ravenhelm.dev/v1/traces
# Expected: 405 (Method Not Allowed - means endpoint is accessible)
```

## Key Insights

### Mixed Content Prevention
- **HTTPS pages cannot make HTTP requests** - browsers block this as "mixed content"
- Solution: Route all telemetry through Traefik using the same protocol as the page
- Use `window.location.protocol` to dynamically match the page's security level

### Dynamic URL Resolution
- Leverage `window.location.origin` and string manipulation for domain-based routing
- Fallback to environment variables for server-side rendering
- Allows single codebase to work across `.test`, `.dev`, and `.ai` environments

### CORS Preflight Priority
- OPTIONS preflight requests must receive CORS headers **before** authentication
- Traefik middleware order matters: `cors` → `secure-headers` → `auth`
- Backend CORS must explicitly whitelist all frontend origins

### Traefik as OTLP Gateway
- Centralize all external traffic through Traefik, including observability
- Benefits:
  - Single TLS termination point
  - Consistent routing patterns
  - Automatic Let's Encrypt certificate management
  - No need for frontend to know about internal ports

## Files Modified
1. `/Users/nwalker/Development/hlidskjalf/hlidskjalf/ui/src/lib/telemetry.ts`
2. `/Users/nwalker/Development/hlidskjalf/ravenhelm-proxy/dynamic.yml`

## Files Verified (No Changes Needed)
1. `/Users/nwalker/Development/hlidskjalf/hlidskjalf/ui/src/lib/api.ts`
2. `/Users/nwalker/Development/hlidskjalf/hlidskjalf/src/main.py`

## Status
✅ Frontend now correctly routes API calls based on current domain  
✅ Telemetry uses HTTPS via Traefik for `.dev` and `.ai` domains  
✅ CORS headers properly configured for all environments  
✅ Mixed content issues resolved

## Testing Checklist
- [ ] Visit `https://hlidskjalf.ravenhelm.dev` and verify dashboard loads
- [ ] Check browser console for CORS errors (should be none)
- [ ] Check browser console for mixed content warnings (should be none)
- [ ] Verify API calls go to `https://hlidskjalf-api.ravenhelm.dev`
- [ ] Verify telemetry goes to `https://otel.ravenhelm.dev`
- [ ] Check Grafana for incoming traces from the frontend
