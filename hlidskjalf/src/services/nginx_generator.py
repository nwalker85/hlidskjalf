"""
Nginx Configuration Generator
Generates nginx configs from port registry for ravenhelm-proxy
"""

from pathlib import Path
from datetime import datetime
from typing import Optional
from jinja2 import Environment, FileSystemLoader
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from structlog import get_logger

from src.core.config import get_settings
from src.models.registry import (
    ProjectRecord,
    PortAllocation,
    NginxRouteRecord,
    Environment as DeployEnv,
    PortType,
)

logger = get_logger(__name__)
settings = get_settings()


# Default nginx server block template
NGINX_SERVER_TEMPLATE = """# =============================================================================
# {{ project.name }} - Auto-generated by Ravenhelm Control Plane
# Generated: {{ generated_at }}
# =============================================================================
{% for route in routes %}
server {
    listen 443 ssl;
    http2 on;
    server_name {{ route.domain }};
    
    ssl_certificate /config/certs/ravenhelm.test.crt;
    ssl_certificate_key /config/certs/ravenhelm.test.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    
    # SPIFFE header for workload identity
    add_header X-SPIFFE-ID "spiffe://{{ trust_domain }}/workload/{{ project.id }}" always;
    
    location / {
        proxy_pass {{ 'https' if route.ssl_upstream else 'http' }}://{{ route.upstream_host }}:{{ route.upstream_port }};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        
        proxy_connect_timeout {{ route.proxy_timeout }}s;
        proxy_send_timeout {{ route.proxy_timeout }}s;
        proxy_read_timeout {{ route.proxy_timeout }}s;
        proxy_buffer_size {{ route.proxy_buffer_size }};
        proxy_buffers 4 {{ route.proxy_buffer_size }};
        
{% for header_name, header_value in route.custom_headers.items() %}
        proxy_set_header {{ header_name }} "{{ header_value }}";
{% endfor %}
    }
}

{% endfor %}
"""


class NginxConfigGenerator:
    """
    Generates nginx configuration from the port registry.
    
    Supports both:
    1. Project-level nginx.conf files (for individual project nginx containers)
    2. ravenhelm-proxy routes (for the central reverse proxy)
    """
    
    def __init__(self, session: AsyncSession):
        self.session = session
        self.trust_domain = settings.TRUST_DOMAIN
    
    async def generate_project_config(
        self,
        project_id: str,
        environment: DeployEnv = DeployEnv.MIDGARD
    ) -> str:
        """Generate nginx config for a specific project"""
        # Get project
        result = await self.session.execute(
            select(ProjectRecord).where(ProjectRecord.id == project_id)
        )
        project = result.scalar_one_or_none()
        
        if not project:
            raise ValueError(f"Project {project_id} not found")
        
        # Get port allocations
        result = await self.session.execute(
            select(PortAllocation).where(
                PortAllocation.project_id == project_id,
                PortAllocation.environment == environment,
            )
        )
        allocations = result.scalars().all()
        
        # Build routes from allocations
        routes = []
        for alloc in allocations:
            if alloc.port_type in [PortType.HTTP, PortType.HTTPS]:
                routes.append({
                    "domain": f"{alloc.service_name}.{project.subdomain}.ravenhelm.test",
                    "upstream_host": "host.docker.internal",
                    "upstream_port": alloc.port,
                    "ssl_upstream": alloc.port_type == PortType.HTTPS,
                    "proxy_timeout": 60,
                    "proxy_buffer_size": "128k",
                    "custom_headers": {},
                })
        
        # Render template
        from jinja2 import Template
        template = Template(NGINX_SERVER_TEMPLATE)
        
        return template.render(
            project=project,
            routes=routes,
            trust_domain=self.trust_domain,
            generated_at=datetime.utcnow().isoformat(),
        )
    
    async def generate_ravenhelm_proxy_config(self) -> str:
        """
        Generate the complete ravenhelm-proxy nginx.conf
        with routes to all registered projects
        """
        # Get all projects with their ports
        result = await self.session.execute(
            select(ProjectRecord)
        )
        projects = result.scalars().all()
        
        # Build configuration
        config_parts = [
            self._generate_header(),
            self._generate_ssl_config(),
        ]
        
        for project in projects:
            # Get HTTPS ports for this project (dev environment)
            result = await self.session.execute(
                select(PortAllocation).where(
                    PortAllocation.project_id == project.id,
                    PortAllocation.environment == DeployEnv.MIDGARD,
                    PortAllocation.port_type.in_([PortType.HTTP, PortType.HTTPS])
                )
            )
            allocations = result.scalars().all()
            
            if allocations:
                config_parts.append(
                    self._generate_project_section(project, allocations)
                )
        
        config_parts.append(self._generate_footer())
        
        return "\n\n".join(config_parts)
    
    def _generate_header(self) -> str:
        return f"""# =============================================================================
# Ravenhelm Proxy - Auto-generated Configuration
# Generated by Ravenhelm Control Plane
# Generated: {datetime.utcnow().isoformat()}
# DO NOT EDIT MANUALLY - Changes will be overwritten
# =============================================================================

worker_processes auto;

events {{
    worker_connections 1024;
}}

http {{
    # Logging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    
    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log warn;
    
    # Performance
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 100M;
    
    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    
    # Upstream resolver for Docker
    resolver 127.0.0.11 valid=30s;
"""

    def _generate_ssl_config(self) -> str:
        return """    # SSL Configuration
    ssl_certificate /config/certs/ravenhelm.test.crt;
    ssl_certificate_key /config/certs/ravenhelm.test.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
    ssl_prefer_server_ciphers on;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 1d;
    
    # HTTP to HTTPS redirect (default server)
    server {
        listen 80 default_server;
        server_name _;
        return 301 https://$host$request_uri;
    }
"""

    def _generate_project_section(
        self,
        project: ProjectRecord,
        allocations: list[PortAllocation]
    ) -> str:
        """Generate server blocks for a project"""
        sections = [f"    # =========== {project.name} ({project.subdomain}) ==========="]
        
        for alloc in allocations:
            domain = f"{alloc.service_name}.{project.subdomain}.ravenhelm.test"
            upstream_port = alloc.port
            
            section = f"""    server {{
        listen 443 ssl;
        http2 on;
        server_name {domain};
        
        # SPIFFE workload identity
        add_header X-SPIFFE-ID "spiffe://{self.trust_domain}/workload/{project.id}" always;
        
        location / {{
            proxy_pass https://host.docker.internal:{upstream_port};
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            proxy_ssl_verify off;
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }}
    }}"""
            sections.append(section)
        
        return "\n\n".join(sections)

    def _generate_footer(self) -> str:
        return """}

# =============================================================================
# End of auto-generated configuration
# =============================================================================
"""

    async def save_route(
        self,
        project_id: str,
        domain: str,
        upstream_host: str,
        upstream_port: int,
        ssl_enabled: bool = True,
    ) -> NginxRouteRecord:
        """Save a custom nginx route to the database"""
        route = NginxRouteRecord(
            project_id=project_id,
            domain=domain,
            upstream_host=upstream_host,
            upstream_port=upstream_port,
            ssl_enabled=ssl_enabled,
        )
        
        self.session.add(route)
        await self.session.commit()
        await self.session.refresh(route)
        
        return route


async def regenerate_nginx_config(session: AsyncSession) -> str:
    """
    Regenerate the full nginx config and return it.
    Call this when ports change or projects are added/removed.
    """
    generator = NginxConfigGenerator(session)
    config = await generator.generate_ravenhelm_proxy_config()
    
    logger.info("Nginx configuration regenerated")
    
    return config

